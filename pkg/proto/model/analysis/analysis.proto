syntax = "proto3";

package bonanza.model.analysis;

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";
import "pkg/proto/model/build/build.proto";
import "pkg/proto/model/command/command.proto";
import "pkg/proto/model/core/core.proto";
import "pkg/proto/model/encoding/encoding.proto";
import "pkg/proto/model/filesystem/filesystem.proto";
import "pkg/proto/model/starlark/starlark.proto";

option go_package = "github.com/buildbarn/bonanza/pkg/proto/model/analysis";

message Action {
  // The X25519 public key that identifies the platform that should be
  // used to execute the action in PKIX, ASN.1 DER form.
  bytes platform_pkix_public_key = 1;

  // Reference to a Command message, containing the command line
  // arguments, environment variables, and set of paths to capture.
  bonanza.model.core.DecodableReference command_reference = 2
      [(bonanza.model.core.object_format) = {
        message_type_name:
          "bonanza.model.command.Command";
      }];

  // Reference to a Directory message, containing the files that need to
  // be present on the worker when executing.
  bonanza.model.core.DecodableReference input_root_reference = 3
      [(bonanza.model.core.object_format) = {
        message_type_name:
          "bonanza.model.filesystem.DirectoryContents";
      }];

  // The timeout that the worker needs to enforce when executing the
  // action.
  google.protobuf.Duration execution_timeout = 4;
}

message ActionResult {
  message Key {
    Action action = 1;
  }

  message Value {
    int64 exit_code = 1;

    bonanza.model.core.DecodableReference outputs_reference = 2
        [(bonanza.model.core.object_format) = {
          message_type_name:
            "bonanza.model.command.Outputs";
        }];
  }
}

message BuildSpecification {
  message Key {}

  message Value {
    bonanza.model.build.BuildSpecification build_specification = 1;
  }
}

message BuiltinsModuleNames {
  message Key {}

  message Value {
    repeated string builtins_module_names = 1;
  }
}

message BuildResult {
  message Key {}

  message Value {}
}

// CanonicalRepoName resolves the canonical name of a repo, given its
// apparent name and the name of the repo which attempts to access it.
message CanonicalRepoName {
  message Key {
    // The canonical name of the repo from which the apparent repo is
    // being accessed.
    //
    // TODO: Should this be reduced to only take a module instance or
    // module extension?
    string from_canonical_repo = 1;

    // The apparent name of the repo which is being accessed.
    string to_apparent_repo = 2;
  }

  message Value {
    // The resolved canonical name of the repo which is being accessed.
    // This may be set to the empty string if no repo exists under the
    // provided apparent repo name.
    string to_canonical_repo = 1;
  }
}

message CommandEncoderObject {
  message Key {}
}

message CommandEncoders {
  message Key {}

  message Value {
    // Encoders that should be used when creating Command messages that
    // are processed by workers.
    repeated bonanza.model.encoding.BinaryEncoder command_encoders = 1;
  }
}

message CommandReaders {
  message Key {}
}

message CompatibleExecutionPlatforms {
  message Key {
    // The constraints that must be present on the execution platform
    // for it to be considered compatible.
    //
    // Constraints whose values correspond to the default value MUST
    // have Constraint.value set to the empty string.
    repeated Constraint constraints = 1;
  }

  message Value {
    // List of platforms that are available for executing commands that
    // match the provided set of constraints, ordered by decreasing
    // preference.
    repeated ExecutionPlatform execution_platforms = 1;
  }
}

message CompatibleToolchainsForType {
  message Key {
    // The label of the toolchain type for which toolchains are
    // requested.
    string toolchain_type = 1;

    // Platform constraints and build settings that are currently active.
    //
    // If this reference is not set, toolchains need to be selected
    // without any platform constraints and build settings in place.
    bonanza.model.core.DecodableReference configuration_reference = 2
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.BuildSettingOverride";
        }];
  }

  message Value {
    // Properties of the toolchains that were registered for the
    // requested type, listed in the order in which registration
    // occurred. An empty list is returned if no toolchains for this
    // type were registered.
    repeated RegisteredToolchain toolchains = 2;
  }
}

message CompiledBzlFile {
  message Key {
    // The label of the .bzl file. The label MUST include a canonical
    // repo name.
    string label = 1;

    repeated string builtins_module_names = 2;
  }

  message Value {
    bonanza.model.starlark.CompiledProgram compiled_program = 1;
  }
}

message CompiledBzlFileDecodedGlobals {
  message Key {
    // The label of the .bzl file. The label MUST include a canonical
    // repo name.
    string label = 1;

    repeated string builtins_module_names = 2;
  }
}

message CompiledBzlFileFunctionFactory {
  message Key {
    // The label of the .bzl file. The label MUST include a canonical
    // repo name.
    string label = 1;

    repeated string builtins_module_names = 2;
  }
}

message CompiledBzlFileGlobal {
  message Key {
    string identifier = 1;
  }

  message Value {
    bonanza.model.starlark.Value global = 1;
  }
}

message BuildSettingOverride {
  message Leaf {
    // The canonical label of the build setting target.
    string label = 1;

    // The value that is assigned to the build setting.
    bonanza.model.starlark.Value value = 2;
  }

  message Parent {
    // Reference to an object containing additional build setting
    // overrides.
    bonanza.model.core.DecodableReference reference = 1
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.BuildSettingOverride";
        }];

    // The label of the first build setting override contained in this
    // B-tree. This field can be used to efficiently look up build
    // setting overrides contained in the B-tree.
    string first_label = 2;
  }

  oneof level {
    // Properties of a single build setting for which an override is
    // in place.
    Leaf leaf = 1;

    // More build setting overrides are stored in another object.
    Parent parent = 2;
  }
}

message Args {
  message Parent {
    // Reference to the B-tree node containing additional arguments.
    bonanza.model.core.DecodableReference reference = 1
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.Args";
        }];
  }

  message Leaf {
    message Add {
      message Parent {
        // Reference to the B-tree node containing additional
        // Args.add*() invocations.
        bonanza.model.core.DecodableReference reference = 1
            [(bonanza.model.core.object_format) = {
              message_list_type_name:
                "bonanza.model.analysis.Args.Leaf.Add";
            }];
      }

      message Leaf {
        // If set, emit a string argument before the values.
        google.protobuf.StringValue start_with = 1;

        // Argument values. This field may only be set to a list or a
        // depset.
        bonanza.model.starlark.Value values = 2;

        // If set, values of type File that reference a directory are
        // expanded to all files recursively contained in that
        // directory.
        bool expand_directories = 3;

        // An optional function that converts each item to zero or more
        // strings, which may be further processed before appending. If
        // not set, standard conversion is performed.
        bonanza.model.starlark.Function map_each = 4;

        // Format string pattern, applied to each string returned by the
        // map_each function. The format string must have exactly one
        // "%s" placeholder.
        string format_each = 5;

        // If true, if there are no arguments derived from values to be
        // appended, then all further processing is suppressed and the
        // command line will be unchanged.
        //
        // If false, the effect depends on the style:
        //
        // - If separate, start_with and separate.terminate_with, if
        //   provided, will still be appended regardless of whether or
        //   not there are other arguments.
        //
        // - If joined, then even if there are no strings to join
        //   together, two arguments will be appended: start_with
        //   followed by an empty string (which is the logical join of
        //   zero strings).
        bool omit_if_empty = 6;

        // If set, duplicate arguments that appear after formatting are
        // removed. The first occurrence is the one that remains.
        bool uniquify = 7;

        message Separate {
          // If set, insert a string argument before each existing
          // argument, effectively doubling the number of arguments to
          // be appended at that point.
          google.protobuf.StringValue before_each = 1;

          // If set, emit a string argument after the values.
          google.protobuf.StringValue terminate_with = 2;
        }

        message Joined {
          // Delimiter used to join together the strings obtained from
          // applying map_each and format_each, in the same manner as
          // string.join().
          string join_with = 1;

          // Format string pattern applied to the joined string. The
          // format string must have exactly one "%s" placeholder.
          string format_joined = 2;
        }

        oneof style {
          // If set, the arguments were declared using Args.add_all().
          Separate separate = 8;

          // If set, the arguments were declared using Args.add_joined().
          Joined joined = 9;
        }
      }

      oneof level {
        // A single Args.add*() invocation.
        Leaf leaf = 1;

        // B-tree node containing additional Args.add*() invocations.
        Parent parent = 2;
      }
    }

    // List of Args.add*() invocations.
    repeated Add adds = 1;

    message UseParamFile {
      enum Format {
        // Each item (argument name or value) is written verbatim to the
        // param file with a newline character following it.
        MULTILINE = 0;

        // Same as MULTILINE, but the items are shell-quoted.
        SHELL = 1;

        // Same as MULTILINE, but:
        //
        // 1. only flags (beginning with '--') are written to the param
        //    file.
        // 2. the values of the flags, if any, are written on the same
        //    line with a '=' separator.
        //
        // This is the format expected by the Abseil flags library.
        FLAG_PER_LINE = 2;
      }

      // The format of the param file.
      Format format = 1;

      // A format string with a single "%s". If the args are spilled to
      // a params file then they are replaced with an argument
      // consisting of this string formatted with the path of the params
      // file.
      //
      // For example, if the args are spilled to a params file
      // "params.txt", then specifying "--file=%s" would cause the
      // action command line to contain "--file=params.txt".
      string param_file_arg = 2;

      // Whether to always spill the args to a params file. If false,
      // whether the arguments need to be spilled will be decided based
      // on system limits and argument length.
      bool use_always = 3;
    }

    // If set, spills the args to a params file, replacing them with a
    // pointer to the param file. Use when your args may be too large
    // for the system's command length limits.
    UseParamFile use_param_file = 2;
  }

  oneof level {
    // A single Args object.
    Leaf leaf = 1;

    // B-tree node containing additional Args objects.
    Parent parent = 2;
  }
}

message TargetActionDefinition {
  // Depset of File objects of the input files of the action.
  repeated bonanza.model.starlark.List.Element inputs = 1;

  // Depset of File objects of the tools used by the action. This field
  // is identical to "inputs", except that it also causes the runfiles
  // directories of these files to be created.
  repeated bonanza.model.starlark.List.Element tools = 2;

  // The X25519 public key that identifies the platform that should be
  // used to execute the action in PKIX, ASN.1 DER form.
  bytes platform_pkix_public_key = 3;

  // Command line arguments of the action. Whereas ctx.actions.run()
  // takes argv[0] and argv[1:] separately, this field contains all of
  // the arguments.
  repeated Args arguments = 4;

  // Pattern of output paths that this action is expected to generate
  // when executed. Output paths are relative to the output directory of
  // the current configuration and package.
  //
  // As this pattern is intended to be directly embeddable into a
  // Command, any objects contained in the pattern should be encoded
  // using the command encoder.
  bonanza.model.command.PathPattern output_path_pattern = 5;

  // Directories that should be present in the output directory prior to
  // running the action. For example, if this action is expected to
  // write to output file "a/b.txt", the initial output directory will
  // contain an empty directory named "a".
  bonanza.model.filesystem.Directory initial_output_directory = 6;

  // Additional environments that need to be present when executing the
  // action. These have a higher precedence than the ones provided by
  // use_default_shell_env or configured on workers.
  repeated bonanza.model.command.EnvironmentVariableList.Element env = 7;

  // If set, use the default shell environment, which consists of a few
  // operating system dependent variables as well as variables set via
  // --action_env.
  bool use_default_shell_env = 8;
}

message ConfiguredTarget {
  message Key {
    // The label of the package. The label MUST include a canonical repo
    // name, and MUST NOT include a target name if it matches the last
    // component of the package path.
    string label = 1;

    // Platform constraints and build settings that are currently active.
    //
    // If this reference is not set, the target is configured without
    // any platform constraints and build settings in place.
    bonanza.model.core.DecodableReference configuration_reference = 2
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.BuildSettingOverride";
        }];
  }

  message Value {
    // The values of the provider instances that this target produced,
    // sorted alphabetically by provider identifier.
    repeated bonanza.model.starlark.Struct provider_instances = 1;

    message Output {
      message Parent {
        // Reference to the B-tree node containing additional outputs.
        bonanza.model.core.DecodableReference reference = 1
            [(bonanza.model.core.object_format) = {
              message_list_type_name:
                "bonanza.model.analysis.ConfiguredTarget.Value.Output";
            }];

        // The package relative path of the first output contained in
        // the B-tree that is referenced.
        string first_package_relative_path = 2;
      }

      message Leaf {
        // The package relative path of the output.
        string package_relative_path = 1;

        message ExpandTemplate {
          // File that contains the template for the output file's
          // contents.
          bonanza.model.starlark.File template = 1;

          // Whether the output file is executable.
          bool is_executable = 2;

          message Substitution {
            bytes needle = 1;
            bytes replacement = 2;
          }

          // Needles to search for in the template, and replacements to
          // emit at the locations where such needs are found.
          repeated Substitution substitutions = 3;
        }

        oneof source {
          // Output of a command that was declared using
          // ctx.actions.run() or ctx.actions.run_shell(). The
          // identifier of the command generating the file is provided.
          bytes action_id = 2;

          // Output of template expansion performed by
          // ctx.actions.expand_template().
          ExpandTemplate expand_template = 3;

          // Output of ctx.actions.symlink(target_path=...) or
          // ctx.actions.write(), provided in the form of a directory
          // hierarchy containing the file or symlink in question,
          // rooted at the output directory of the current package and
          // configuration.
          bonanza.model.filesystem.DirectoryContents static_package_directory =
              4;

          // Output of ctx.actions.symlink(target_file=...).
          bonanza.model.starlark.File symlink = 5;
        }
      }

      oneof level {
        // A single output, for which properties are provided.
        Leaf leaf = 1;

        // B-tree node containing additional outputs.
        Parent parent = 2;
      }
    }

    // The output directories, files and symbolic links that this target
    // declared as part of its implementation function using
    // ctx.actions.declare_{directory,file,symlink}(), or predeclared
    // using attr.output{,_list}().
    //
    // Outputs are stored in a B-tree, where entries are sorted
    // alphabetically by package relative path.
    repeated Output outputs = 2;

    message Action {
      message Parent {
        // Reference to the B-tree node containing additional actions.
        bonanza.model.core.DecodableReference reference = 1
            [(bonanza.model.core.object_format) = {
              message_list_type_name:
                "bonanza.model.analysis.ConfiguredTarget.Value.Action";
            }];

        // The identifier of the first output contained in the B-tree
        // that is referenced.
        bytes first_id = 2;
      }

      message Leaf {
        // The identifier of the action. This identifier can be used by
        // outputs to reference the action that generates them.
        bytes id = 1;

        // The definition of the action, describing its arguments,
        // inputs and expected outputs.
        TargetActionDefinition definition = 2;
      }

      oneof level {
        // A single action, for which properties are provided.
        Leaf leaf = 1;

        // B-tree node containing additional actions.
        Parent parent = 2;
      }
    }

    repeated Action actions = 3;
  }
}

message DirectoryAccessParameters {
  message Key {}

  message Value {
    bonanza.model.filesystem.DirectoryAccessParameters
        directory_access_parameters = 1;
  }
}

message DirectoryCreationParameters {
  message Key {}

  message Value {
    bonanza.model.filesystem.DirectoryCreationParameters
        directory_creation_parameters = 1;
  }
}

message DirectoryCreationParametersObject {
  message Key {}
}

message DirectoryReaders {
  message Key {}
}

message EmptyDefaultInfo {
  message Key {}

  message Value {
    // An instance of DefaultInfo that has all of its fields set to
    // their default values.
    bonanza.model.starlark.Struct default_info = 1;
  }
}

message ExecTransition {
  message Key {
    // The label of the platform that was resolved for the exec group
    // referenced by the attribute.
    string platform_label = 1;

    // The configuration from which inputs need to be sourced.
    bonanza.model.core.DecodableReference input_configuration_reference = 2
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.BuildSettingOverride";
        }];
  }

  message Value {
    // The configuration that should be used to configure the attribute
    // that has cfg = "exec" or cfg = exec_group(...).
    bonanza.model.core.DecodableReference output_configuration_reference = 2
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.BuildSettingOverride";
        }];
  }
}

message FileAccessParameters {
  message Key {}

  message Value {
    bonanza.model.filesystem.FileAccessParameters file_access_parameters = 1;
  }
}

message FileCreationParameters {
  message Key {}

  message Value {
    bonanza.model.filesystem.FileCreationParameters file_creation_parameters =
        1;
  }
}

message FileCreationParametersObject {
  message Key {}
}

message FileProperties {
  message Key {
    // The canonical name of the repo that contains the file whose
    // properties are being requested.
    string canonical_repo = 1;

    // Path of the files whose properties are being requested, relative
    // to the root of the repo. The path MUST NOT contain "." or ".."
    // components. It also MUST NOT contain leading, trailing, or
    // redundant slashes.
    string path = 2;
  }

  message Value {
    // If set, the file exists, and its properties are provided.
    bonanza.model.filesystem.FileProperties exists = 1;
  }
}

message FileReader {
  message Key {}
}

message FileListRoot {
  message Key {
    // Reference to a Starlark list containing files.
    bonanza.model.core.DecodableReference list_reference = 1
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.starlark.List.Element";
        }];
  }

  message Value {
    // A directory hierarchy that contains all of the files contained in
    // the list, placed at the location they would appear inside the
    // input root of an action that depends on them.
    bonanza.model.filesystem.DirectoryContents root_directory = 1;
  }
}

message FileRoot {
  message Key {
    // The source file or output file's contents that are being requested.
    bonanza.model.starlark.File file = 1;
  }

  message Value {
    // A directory hierarchy that contains the requested file, placed at
    // the location it would appear inside the input root of an action
    // that depends on it.
    //
    // If the requested file is a symlink, its target(s) will also be
    // part of the directory structure.
    bonanza.model.filesystem.DirectoryContents root_directory = 1;
  }
}

message FilesInPackage {
  message Key {
    // The package for which the list of files it contains is requested.
    string package = 1;
  }

  message Value {
    // Directory of the package, with child directories removed that
    // belong to nested packages. Furthermore, file contents are
    // removed, thereby making all files empty.
    bonanza.model.filesystem.DirectoryContents directory = 1;
  }
}

message Glob {
  message Key {
    // The package in which the call to glob() is made.
    string package = 1;

    // A nondeterministic finite automaton (NFA) that describes the
    // paths to match. The NFA is encoded as a sequence of states, where
    // each state has the following format:
    //
    // - A variable length integer, which can be interpreted as follows:
    //
    //   - Bits 0 and 1: If set to zero, the current state is not an end
    //     state. If set to one, the current state is an end state and
    //     the parsed string is a match. If set to two, the current
    //     state is an end state and the parsed string is not a match.
    //     When parsing completes while in multiple states, the highest
    //     value takes precedence.
    //
    //     States for wildcard "**/" cannot be an end state.
    //
    //   - Bit 2: If set, the current state has an outgoing edge for
    //     wildcard "*". This bit cannot be set if the current state
    //     already corresponds to wildcard "*".
    //
    //   - Bit 3: If set, the current state has an outgoing edge for
    //     wildcard "**/". This bit can only be set as part of the
    //     initial state, or if the current state corresponds to regular
    //     character "/".
    //
    //   - Bits 4 and above: The number of outgoing edges the current
    //     state has for regular (non-wildcard) characters.
    //
    // - A sequence of UTF-8 encoded characters, corresponding to the
    //   characters assigned to the outgoing edges of the current state.
    //   These characters must be provided in sorted order.
    //
    // States are stored in the order in which they are referenced by
    // their parent (i.e., "*" followed by "**/" followed by regular
    // characters), breadth first.
    bytes pattern = 2;

    // Whether or not to include paths in the results that correspond to
    // directories.
    bool include_directories = 3;
  }

  message Value {
    // Set of relative paths below the package's directory that are
    // matched by one or more of the include patterns and none of the
    // exclude patterns.
    //
    // Paths are sorted alphabetically, with the '/' character having no
    // special meaning.
    repeated string matched_paths = 1;
  }
}

message SubresourceIntegrity {
  enum HashAlgorithm {
    SHA256 = 0;
    SHA384 = 1;
    SHA512 = 2;
  }

  // Hash algorithm that was used to compute the Subresource Integrity.
  HashAlgorithm hash_algorithm = 1;

  // Hash value associated with the Subresource Integrity.
  bytes hash = 2;
}

message HttpFetchOptions {
  // The URLs to fetch.
  repeated string urls = 1;

  // Optional checksum of the file to download, provided in the
  // Subresource Integrity (SRI) format.
  SubresourceIntegrity integrity = 2;

  // If not set, let the function fail if the server returns a HTTP
  // status code other than 200 and 404.
  bool allow_fail = 3;

  message Header {
    // Name of the HTTP header to set.
    string name = 1;

    // Value to assign to the HTTP header.
    string value = 2;
  }

  // HTTP headers to send to servers as part of outgoing requests.
  repeated Header headers = 4;
}

message HttpArchiveContents {
  message Key {
    // URLs and options for determining how to fetch the file.
    HttpFetchOptions fetch_options = 1;

    enum Format {
      // The format of the archive is not specified.
      UNKNOWN = 0;

      // Gzip compressed tarball.
      TAR_GZ = 1;

      // XZ compressed tarball.
      TAR_XZ = 2;

      // ZIP archive, using the file format documented at
      // https://support.pkware.com/pkzip/appnote.
      ZIP = 3;
    }

    // The format of the archive.
    Format format = 2;
  }

  message Value {
    message Exists {
      // The contents of the archive.
      //
      // The directory hierarchy MUST NOT contain any symbolic links
      // whose targets escape the root directory (i.e.,
      // maximum_symlink_escapement_levels MUST be zero).
      bonanza.model.filesystem.DirectoryReference contents = 1;

      // A SHA-256 hash of the archive that was downloaded. This field
      // is only set if no integrity was provided as part of
      // fetch_options.
      bytes sha256 = 2;
    }

    // If set, the archive was fetched and extracted successfully. If
    // not set, fetching the file failed with a non-200 HTTP status
    // code.
    Exists exists = 1;
  }
}

message HttpFileContents {
  message Key {
    // URLs and options for determining how to fetch the file.
    HttpFetchOptions fetch_options = 1;
  }

  message Value {
    message Exists {
      // The contents of the file, if the file was non-empty.
      bonanza.model.filesystem.FileContents contents = 1;

      // A SHA-256 hash of the file that was downloaded. This field is
      // only set if no integrity was provided as part of fetch_options.
      bytes sha256 = 2;
    }

    // If set, the file was fetched successfully. If not set, fetching
    // the file failed with a non-200 HTTP status code.
    Exists exists = 1;
  }
}

message ModuleDotBazelContents {
  message Key {
    // The module instance whose MODULE.bazel file needs to be obtained.
    string module_instance = 1;
  }

  message Value {
    // The contents of the module instance's MODULE.bazel file, if the
    // file was non-empty.
    bonanza.model.filesystem.FileContents contents = 1;
  }
}

message ModuleRegistryUrls {
  message Key {}

  message Value {
    // URLs of registries from which modules may be downloaded.
    repeated string registry_urls = 1;
  }
}

message ModuleRepoMapping {
  message Key {
    // The module instance for which a mapping of repos needs to be
    // computed.
    string module_instance = 1;
  }

  message Value {
    message Mapping {
      // The name of the apparent repo that is visible from within the
      // module.
      string from_apparent_repo = 1;

      // The name of the canonical repo to which the apparent repo
      // maps.
      string to_canonical_repo = 2;
    }

    // The list of repos that can be accessed from within this module
    // instance, sorted alphabetically by apparent repo.
    repeated Mapping mappings = 1;
  }
}

message ModuleExtensionRepo {
  message Key {
    string canonical_repo = 1;
  }

  message Value {
    bonanza.model.starlark.Repo.Definition definition = 1;
  }
}

message ModuleExtensionRepoNames {
  message Key {
    // Name of the module extension for which the names of the repos it
    // declares should be computed.
    string module_extension = 1;
  }

  message Value {
    // Names of repos declared by the module extensions, sorted by name.
    repeated string repo_names = 1;
  }
}

message ModuleExtensionRepos {
  message Key {
    string module_extension = 1;
  }

  message Value {
    message Repo {
      message Parent {
        // Reference to an object with a list of Repo messages that
        // contains properties of repos in the module extension.
        bonanza.model.core.DecodableReference reference = 1
            [(bonanza.model.core.object_format) = {
              message_list_type_name:
                "bonanza.model.analysis.ModuleExtensionRepos.Value.Repo";
            }];

        // The name of the first repo contained in this B-tree.
        // This field can be used to efficiently look up repos
        // contained in the B-tree.
        string first_name = 2;
      }

      oneof level {
        // Properties of a single repo.
        bonanza.model.starlark.Repo leaf = 1;

        // More repos are stored in another object.
        Parent parent = 2;
      }
    }

    // Successfully executed the module extension's implementation
    // function, and extracted the repos declared by it.
    repeated Repo repos = 1;
  }
}

message BuildListModule {
  // The name of the module.
  string name = 1;

  // The version of the module.
  string version = 2;

  // The compatibility level of the module.
  int32 compatibility_level = 3;

  // The URL of the registry in which the module was found.
  string registry_url = 4;
}

message ModuleFinalBuildList {
  message Key {}

  message Value {
    // Modules that were referenced by the main module, or one of
    // transitive dependencies, sorted by name and version.
    repeated BuildListModule build_list = 1;
  }
}

message ModuleRoughBuildList {
  message Key {}

  message Value {
    repeated BuildListModule build_list = 1;
  }
}

message OverridesListModule {
  // Name of the module.
  string name = 1;

  // If multiple_version_override() is called, a sorted list of
  // version numbers that are permitted to coexist.
  repeated string versions = 2;
}

message ModulesWithMultipleVersions {
  message Key {}

  message Value {
    // Alphabetically sorted list of modules for which overrides are
    // in place. For these modules, computation of the rough build
    // list may assume that sources can be accessed directly, without
    // needing to separately load a MODULE.bazel file from Bazel
    // Central Registry (BCR).
    repeated OverridesListModule overrides_list = 1;
  }
}

message ModulesWithMultipleVersionsObject {
  message Key {}
}

message ModulesWithOverrides {
  message Key {}

  message Value {
    // Alphabetically sorted list of modules for which overrides are
    // in place. For these modules, computation of the rough build
    // list may assume that sources can be accessed directly, without
    // needing to separately load a MODULE.bazel file from Bazel
    // Central Registry (BCR).
    repeated OverridesListModule overrides_list = 1;
  }
}

message ModuleOverride {
  // Name of the module.
  string name = 1;

  message SingleVersion {
    // Version of the module to use.
    string version = 1;

    // Registry to pull the version from.
    string registry = 2;

    // Patch labels are not sorted as they are applied in order.
    repeated string patch_labels = 4;

    // Patch commands are not sorted as they are applied in order.
    repeated string patch_commands = 5;

    // Strip is the same as the -p argument of Unix patch.
    int64 patch_strip = 6;
  }

  message MultipleVersions {
    // Versions is a list of sorted versions allowed to explicitly coexist.
    repeated string versions = 1;

    // Registry to pull the versions from.
    string registry = 2;
  }

  // Kind of the override for the module name.
  oneof kind {
    // See: https://bazel.build/rules/lib/globals/module#single_version_override
    SingleVersion single_version = 2;

    // See:
    // https://bazel.build/rules/lib/globals/module#multiple_version_override
    MultipleVersions multiple_versions = 3;

    // Repository rule is the definition for the rule.
    // See: https://bazel.build/rules/lib/globals/module#archive_override
    // See: https://bazel.build/rules/lib/globals/module#git_override
    bonanza.model.starlark.Repo.Definition repository_rule = 4;
  }
}

message ModulesWithRemoteOverrides {
  message Key {}

  message Value {
    // Alphabetically sorted list of modules for which remote overrides are in
    // place.
    repeated ModuleOverride module_overrides = 1;
  }
}

message Package {
  message Key {
    // The label of the package. The label MUST include a canonical repo
    // name, and MUST NOT include a target name.
    string label = 1;
  }

  message Value {
    message Target {
      message Parent {
        // Reference to an object with a list of Target messages that
        // contain properties of targets in the package.
        bonanza.model.core.DecodableReference reference = 1
            [(bonanza.model.core.object_format) = {
              message_list_type_name:
                "bonanza.model.analysis.Package.Value.Target";
            }];

        // The name of the first target contained in this B-tree.
        // This field can be used to efficiently look up targets
        // contained in the B-tree.
        string first_name = 2;
      }

      oneof level {
        // Properties of a single target.
        bonanza.model.starlark.Target leaf = 1;

        // More targets are stored in another object.
        Parent parent = 2;
      }
    }

    // Successfully processed the package's BUILD.bazel file, and
    // extracted the targets contained within.
    repeated Target targets = 1;
  }
}

message PackagesAtAndBelow {
  message Key {
    // Repo and package prefix at which the lookup should start.
    string base_package = 1;
  }

  message Value {
    // If set, the directory corresponding to the base package contains
    // a BUILD.bazel or BUILD file.
    bool package_at_base_package = 1;

    // List of relative paths that can be appended to the base package
    // to obtain packages below the base package containing a
    // BUILD.bazel or BUILD file. Paths are sorted lexicographically by
    // their components.
    repeated string packages_below_base_package = 2;
  }
}

message Constraint {
  // The label of the constraint_setting() target.
  string setting = 1;

  // The label of the constraint_value() target.
  string value = 2;
}

message ExecutionPlatform {
  // Canonical label of the platform target. When this platform is
  // selected, the --platforms flag will be assigned to this target.
  string label = 1;

  // Constraints that apply to the execution platform, such as the
  // CPU architecture or operating system. Constraints are sorted
  // alphabetically by setting.
  //
  // Constraints for which the value is equal to the default value of
  // the setting are omitted.
  repeated Constraint constraints = 2;

  // The X25519 public key that identifies the platform that should be
  // used to execute the action in PKIX, ASN.1 DER form.
  bytes exec_pkix_public_key = 3;

  // TODO: Also add flags, required_settings, etc.?
}

message RegisteredExecutionPlatforms {
  message Key {}

  message Value {
    // List of platforms that are available for executing commands,
    // ordered by decreasing preference.
    repeated ExecutionPlatform execution_platforms = 1;
  }
}

message RegisteredRepoPlatform {
  message Key {}

  message Value {
    message EnvironmentVariable {
      // The name of the environment variable.
      string name = 1;

      // The value of the environment variable.
      string value = 2;
    }

    // The X25519 public key that identifies the platform that should be
    // used to execute the action in PKIX, ASN.1 DER form.
    bytes exec_pkix_public_key = 1;

    // The name of the architecture to announce via repository_os.arch.
    string repository_os_arch = 2;

    // Environment variables to announce via repository_os.environ.
    repeated EnvironmentVariable repository_os_environ = 3;

    // The name of the operating system to announce via
    // repository_os.name.
    string repository_os_name = 4;
  }
}

message RegisteredToolchain {
  // List of constraints that must be satisfied by an execution platform
  // in order for this toolchain to be selected for a target building on
  // that platform.
  //
  // Constraints for which the value is equal to the default value of
  // the setting have their value set to the empty string.
  repeated Constraint exec_compatible_with = 1;

  // List of constraints that must be satisfied by the target platform
  // in order for this toolchain to be selected for a target building
  // for that platform.
  //
  // Constraints for which the value is equal to the default value of
  // the setting have their value set to the empty string.
  repeated Constraint target_compatible_with = 2;

  // List of config_settings that must be satisfied by the target
  // configuration in order for this toolchain to be selected during
  // toolchain resolution.
  repeated string target_settings = 3;

  // Label of target representing the actual tool or tool suite that is
  // made available when this toolchain is selected.
  //
  // As toolchain targets are typically placed in other repos, this
  // label may still refer to an alias that needs to be expanded.
  string toolchain = 4;
}

message RegisteredToolchains {
  message Key {}

  message Value {
    message RegisteredToolchainType {
      // The label of the toolchain type for which one or more
      // toolchains are registered.
      string toolchain_type = 1;

      // Properties of the toolchains that were registered, listed in
      // the order in which registration occurred.
      repeated RegisteredToolchain toolchains = 2;
    }

    // Toolchain types for which one or more toolchains are registered,
    // sorted by toolchain type label.
    repeated RegisteredToolchainType toolchain_types = 1;
  }
}

message RegisteredToolchainsForType {
  message Key {
    // The label of the toolchain type for which toolchains are
    // requested.
    string toolchain_type = 1;
  }

  message Value {
    // Properties of the toolchains that were registered for the
    // requested type, listed in the order in which registration
    // occurred. An empty list is returned if no toolchains for this
    // type were registered.
    repeated RegisteredToolchain toolchains = 2;
  }
}

message Repo {
  message Key {
    // The canonical name of the repo whose file contents are being
    // requested.
    string canonical_repo = 1;
  }

  message Value {
    // The root directory containing the files in the repository.
    //
    // For this directory, maximum_symlink_escapement_levels may only
    // have one of the following values:
    //
    // - 0: The repo does not contain any symbolic links, or all
    //   symbolic links expand to paths within the same repo.
    //
    // - 1: The repo contains symbolic links that expand to paths in
    //   other repos (e.g., "../other_repo/hello.txt").
    bonanza.model.filesystem.DirectoryReference root_directory_reference = 1;
  }
}

message RepoDefaultAttrs {
  message Key {
    // The canonical name of the repo for which the defaults specified
    // in REPO.bazel are requested.
    string canonical_repo = 1;
  }

  message Value {
    // Default values of attributes that need to be attached to all
    // targets in this repo.
    bonanza.model.starlark.InheritableAttrs inheritable_attrs = 1;
  }
}

message RepoPlatformHostPath {
  message Key {
    // Absolute path of a file or directory on workers of the repo
    // platform whose contents should be captured. If the path refers to
    // a symlink, it should be followed.
    string absolute_path = 1;
  }

  message Value {
    oneof captured_path {
      // The provided path corresponds to (a symlink pointing to) a
      // file. The contents of the file are provided.
      bonanza.model.filesystem.FileProperties file = 1;

      // The provided path corresponds to (a symlink pointing to) a
      // directory. The resulting directory may not contain any symlinks
      // that escape the directory hierarchy. If such symlinks are
      // encountered when creating this directory, they are expanded.
      bonanza.model.filesystem.DirectoryContents directory = 2;
    }
  }
}

message ResolvedToolchains {
  message Key {
    // List of constraints that must be satisfied by an execution
    // platform in order for this toolchain to be selected for a target
    // building on that platform.
    //
    // Constraints for which the value is equal to the default value of
    // the setting have their value set to the empty string.
    repeated Constraint exec_compatible_with = 1;

    // Platform constraints and build settings that are currently active.
    //
    // If this reference is not set, toolchains needd to be resolved
    // without any platform constraints and build settings in place.
    bonanza.model.core.DecodableReference configuration_reference = 2
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.BuildSettingOverride";
        }];

    // The set of toolchains to resolve, and any constraints placed on
    // the execution platform.
    repeated bonanza.model.starlark.ToolchainType toolchains = 3;
  }

  message Value {
    // Identifiers of the resolved toolchains, using the same order as
    // the toolchain types in the key. Any optional toolchains that
    // could not be resolved will have their identifier set to the
    // empty string.
    repeated string toolchain_identifiers = 1;

    // Label of an execution platform that is capable of running actions
    // using executables that are part of the resolved toolchains.
    string platform_label = 2;

    // The X25519 public key that identifies the execution platform that
    // is capable of running executables that are part of the resolved
    // toolchains, in PKIX, ASN.1 DER form.
    bytes platform_pkix_public_key = 3;
  }
}

message RootModule {
  message Key {}

  message Value {
    // The name of the root module.
    string root_module_name = 1;

    // Whether to ignore `bazel_dep` and `use_extension` declared as
    // `dev_dependency` in the MODULE.bazel of the root module. Note
    // that such dependencies are always ignored in the MODULE.bazel
    // file of modules other than the root module.
    bool ignore_root_module_dev_dependencies = 2;
  }
}

message RuleImplementationWrappers {
  message Key {}
}

message Select {
  message Key {
    // Condition identifiers from which a selection needs to be made.
    repeated string condition_identifiers = 1;

    // Platform constraints and build settings that are currently active.
    //
    // If this reference is not set, conditions are selected without any
    // platform constraints and build settings in place.
    bonanza.model.core.DecodableReference configuration_reference = 2
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.BuildSettingOverride";
        }];

    // The package that invokes select().
    string from_package = 3;
  }

  message Value {
    // Indices of conditions which are selected.
    //
    // If an empty list is returned, the default condition should be
    // selected. If multiple indices are returned, multiple conditions
    // match that are not specializations of each other. In that case
    // the caller should check whether the values associated with the
    // conditions are identical.
    repeated uint32 condition_indices = 1;
  }
}

message StableInputRootPath {
  message Key {}

  message Value {
    // The path at which workers belonging to the registered repo
    // platform expose input roots.
    //
    // Repository rules and module extensions often make assumptions
    // about the absolute locations at which repositories are created.
    // Functions like module_ctx.path() and repository_ctx.path() should
    // return absolute paths that are representative of w
    string input_root_path = 1;
  }
}

message StableInputRootPathObject {
  message Key {}
}

message SuccessfulActionResult {
  message Key {
    Action action = 1;
  }

  message Value {
    bonanza.model.core.DecodableReference outputs_reference = 2
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.command.Outputs";
        }];
  }
}

message Target {
  message Key {
    // The label of the target whose properties to obtain.
    string label = 1;
  }

  message Value {
    bonanza.model.starlark.Target.Definition definition = 1;
  }
}

message TargetActionId {
  // The label of the target that declared the action.
  string label = 1;

  // The configuration that was used to compute the configured target
  // declaring the action.
  bonanza.model.core.DecodableReference configuration_reference = 2
      [(bonanza.model.core.object_format) = {
        message_list_type_name:
          "bonanza.model.analysis.BuildSettingOverride";
      }];

  // The identifier of the action within the configured target.
  bytes action_id = 3;
}

message TargetAction {
  message Key {
    // The identifier of the target action.
    TargetActionId id = 1;
  }

  message Value {
    // The definition of the action.
    TargetActionDefinition definition = 1;
  }
}

message TargetActionCommand {
  message Key {
    // The identifier of the target action.
    TargetActionId id = 1;
  }

  message Value {
    bonanza.model.core.DecodableReference command_reference = 1
        [(bonanza.model.core.object_format) = {
          message_type_name:
            "bonanza.model.command.Command";
        }];
  }
}

message TargetActionInputRoot {
  message Key {
    // The identifier of the target action.
    TargetActionId id = 1;
  }

  message Value {
    bonanza.model.core.DecodableReference input_root_reference = 1
        [(bonanza.model.core.object_format) = {
          message_type_name:
            "bonanza.model.filesystem.DirectoryContents";
        }];
  }
}

message TargetActionResult {
  message Key {
    // The identifier of the target action.
    TargetActionId id = 1;
  }

  message Value {
    // The contents of output files and directories of this action.
    bonanza.model.filesystem.DirectoryContents output_root = 1;
  }
}

message TargetCompletion {
  message Key {
    // The label of the package. The label MUST include a canonical repo
    // name, and MUST NOT include a target name if it matches the last
    // component of the package path.
    string label = 1;

    // Platform constraints and build settings that are currently active.
    //
    // If this reference is not set, the target is built without any
    // platform constraints and build settings in place.
    bonanza.model.core.DecodableReference configuration_reference = 2
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.BuildSettingOverride";
        }];
  }

  message Value {}
}

message TargetPatternExpansion {
  message Key {
    // The target pattern that needs to be expanded to a set of targets.
    // The target pattern MUST include a canonical repo name.
    string target_pattern = 1;

    // Whether to include targets that have tag "manual". These should
    // be excluded as part of "bazel build", but included as part of
    // "bazel query".
    bool include_manual_targets = 2;
  }

  message Value {
    message TargetLabel {
      message Parent {
        // Reference to an object of type TargetLabelList that
        // contains a list of labels of targets matched by the
        // target pattern.
        bonanza.model.core.DecodableReference
            reference = 1 [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.TargetPatternExpansion.Value.TargetLabel";
        }];
      }

      oneof level {
        // Label of a single target matched by the target pattern.
        string leaf = 1;

        // More labels of targets are stored in another object.
        Parent parent = 2;
      }
    }

    // Successfully processed the target pattern, and extracted the
    // labels of targets matched by the target pattern.
    repeated TargetLabel target_labels = 1;
  }
}

message ModuleExtension {
  message User {
    // The module instance that uses the module extension.
    string module_instance = 1;

    // Whether the module instance is the root module.
    bool is_root = 2;

    // Tag classes for which one or more tags are provided by this
    // module instance.
    repeated TagClass tag_classes = 3;
  }

  message TagClass {
    // Starlark identifier of the tag class.
    string name = 1;

    // One or more tags of this class that have been provided.
    repeated Tag tags = 2;
  }

  message Tag {
    // Attributes that are provided to this tag.
    //
    // No attempts have been performed to canonicalize the values of
    // these attributes. For example, this means that labels may be
    // stored as plain strings that later on need to be resolved to the
    // proper canonical target.
    bonanza.model.starlark.Struct.Fields attrs = 1;

    // Whether the tag was specified on the result of a use_extension()
    // call with dev_dependency = True.
    bool is_dev_dependency = 2;
  }

  // Canonical Starlark identifier of the module_extension() object.
  string identifier = 1;

  // Modules instances that use the module extension. The order of this
  // list is the same as a breadth-first search starting from the root
  // module.
  repeated User users = 2;
}

message RepositoryRuleObject {
  message Key {
    // The canonical Starlark identifier of the repository rule whose
    // properties need to be obtained.
    string identifier = 1;
  }
}

message UsedModuleExtension {
  message Key {
    string module_extension = 1;
  }

  message Value {
    ModuleExtension module_extension = 1;
  }
}

message UsedModuleExtensions {
  message Key {}

  message Value {
    // List of module extensions that has one or more users. Module
    // extensions are sorted by module extension name, which can be
    // derived from the canonical Starlark identifier of the
    // module_extension() object.
    repeated ModuleExtension module_extensions = 1;
  }
}

message UserDefinedTransition {
  message Key {
    // The Starlark identifier of the transition to apply.
    string transition_identifier = 1;

    // The configuration from which inputs need to be sourced.
    bonanza.model.core.DecodableReference input_configuration_reference = 2
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.BuildSettingOverride";
        }];
  }

  message Value {
    message Success {
      message Entry {
        // Key by which the output configuration is identified.
        string key = 1;

        // Output configuration that is identified by this key.
        bonanza.model.core.DecodableReference output_configuration_reference = 2
            [(bonanza.model.core.object_format) = {
              message_list_type_name:
                "bonanza.model.analysis.BuildSettingOverride";
            }];
      }

      // Dictionary of output configurations yielded by the transition.
      // Entries are sorted alphabetically by key.
      repeated Entry entries = 1;
    }

    oneof result {
      // The transition could not be computed, because the transition is
      // an outgoing edge transition that depends on attrs of the target
      // to which the transition is attached. The caller is responsible
      // for computing the transition manually.
      google.protobuf.Empty transition_depends_on_attrs = 1;

      // The transition yielded a dictionary of configurations, where
      // each configuration is identified by a string.
      Success success = 2;
    }
  }
}

message VisibleTarget {
  message Key {
    // The package that references the label.
    string from_package = 1;

    // The label being referenced.
    string to_label = 2;

    // Don't fail if the target is an alias() that contains a select()
    // expression that does not many any of the conditions. In that case the
    // resulting label will be set to the empty string.
    //
    // This may be used to suppress errors in case the provided label
    // was obtained by expanding a target pattern, and any incompatible
    // targets should be ignored, (e.g., as part of
    // register_toolchains()).
    bool permit_alias_no_match = 3;

    // Platform constraints and build settings that are currently active.
    //
    // If this reference is not set, the alias is resolved without any
    // platform constraints and build settings into account.
    bonanza.model.core.DecodableReference configuration_reference = 4
        [(bonanza.model.core.object_format) = {
          message_list_type_name:
            "bonanza.model.analysis.BuildSettingOverride";
        }];

    // Instead expanding targets of type label_setting() taking the
    // configuration into account, return the label identifier of the
    // label_setting() itself.
    bool stop_at_label_setting = 5;
  }

  message Value {
    // The label of the target after aliases are expanded and visibility
    // is checked.
    //
    // Even if permit_alias_no_match is not set, this value may be left
    // empty if the target is a label setting for which no explicit
    // default value is set.
    string label = 1;
  }
}
